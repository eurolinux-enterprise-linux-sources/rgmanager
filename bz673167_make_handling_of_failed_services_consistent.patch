commit fb1683ce90ef47556b978707363e31f703113b6c
Author: Lon Hohberger <lhh@redhat.com>
Date:   Wed Jul 6 17:00:57 2011 -0400

    rgmanager: Make handling of failed services consistent
    
    Resolves: rhbz#673167
    
    Signed-off-by: Lon Hohberger <lhh@redhat.com>
    Reviewed-by: Fabio M. Di Nitto <fdinitto@redhat.com>

diff --git a/rgmanager/include/resgroup.h b/rgmanager/include/resgroup.h
index 2e81eb9..7119eac 100644
--- a/rgmanager/include/resgroup.h
+++ b/rgmanager/include/resgroup.h
@@ -196,6 +196,7 @@ int rg_unlock(struct dlm_lksb *p);
 
 
 /* Return codes */
+#define RG_EWARNING	-19		/* Warning (see logs) */
 #define RG_EPERM	-18		/* Permission denied */
 #define RG_ERELO	-17		/* Relocation failure; service running
 					   on original node */
diff --git a/rgmanager/src/clulib/rg_strings.c b/rgmanager/src/clulib/rg_strings.c
index b0cd184..868b91b 100644
--- a/rgmanager/src/clulib/rg_strings.c
+++ b/rgmanager/src/clulib/rg_strings.c
@@ -8,7 +8,8 @@ struct string_val {
 
 
 const struct string_val rg_error_strings[] = {
-	{ RG_EPERM,	"Permissing denied" },
+	{ RG_EWARNING,	"Warning; see system logs" },
+	{ RG_EPERM,	"Permission denied" },
 	{ RG_ERELO,	"Failed; service running on original owner" },
 	{ RG_EEXCL,	"Service not runnable: cannot run exclusive" },
 	{ RG_EDOMAIN,   "Service not runnable" },
diff --git a/rgmanager/src/daemons/rg_state.c b/rgmanager/src/daemons/rg_state.c
index babac7a..5501b3f 100644
--- a/rgmanager/src/daemons/rg_state.c
+++ b/rgmanager/src/daemons/rg_state.c
@@ -1434,11 +1434,23 @@ _svc_stop(const char *svcName, int req, int recover, uint32_t newstate)
 
 	ret = group_op(svcName, RG_STOP);
 
-	if (old_state == RG_STATE_FAILED && newstate == RG_STATE_DISABLED) {
-		if (ret)
+	/* fix up return code on failure during disable */
+	if (ret)
+		ret = RG_EFAIL;
+
+	if ((old_state == RG_STATE_FAILED ||
+	     old_state == RG_STATE_DISABLED) &&
+	    newstate == RG_STATE_DISABLED) {
+		if (ret) {
+			/*
+			 * Return warning on disable-after-fail.
+			 * (mark it disabled anyway)
+			 */
 			logt_print(LOG_ALERT, "Marking %s as 'disabled', "
 			       "but some resources may still be allocated!\n",
 			       svcName);
+			ret = RG_EWARNING;
+		}
 		_svc_stop_finish(svcName, 0, newstate);
 	} else {
 		_svc_stop_finish(svcName, ret, newstate);
@@ -1474,8 +1486,10 @@ _svc_stop_finish(const char *svcName, int failed, uint32_t newstate)
 		return 0;
 	}
 
-	svcStatus.rs_last_owner = svcStatus.rs_owner;
-	svcStatus.rs_owner = 0;
+	if (svcStatus.rs_owner != 0) {
+		svcStatus.rs_last_owner = svcStatus.rs_owner;
+		svcStatus.rs_owner = 0;
+	}
 
 	if (failed) {
 		logt_print(LOG_CRIT, "#12: RG %s failed to stop; intervention "
@@ -1819,7 +1833,7 @@ handle_relocate_req(char *svcName, int orig_request, int preferred_target,
 		ret = _svc_stop(svcName, request, 0, RG_STATE_STOPPED);
 		if (ret == RG_EFAIL) {
 			svc_fail(svcName);
-			return RG_EFAIL;
+			return RG_EABORT;
 		}
 		if (ret == RG_EFROZEN) {
 			return RG_EFROZEN;

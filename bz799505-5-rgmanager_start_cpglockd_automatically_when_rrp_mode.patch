From 9a583d796f1f13b6b836eb140bdbda05d3c95a01 Mon Sep 17 00:00:00 2001
From: Ryan McCabe <rmccabe@redhat.com>
Date: Mon, 23 Apr 2012 10:49:29 -0400
Subject: [PATCH] rgmanager: Start cpglockd automatically when RRP mode
 is enabled

Signed-off-by: Ryan McCabe <rmccabe@redhat.com>
Reviewed-by: Lon Hohberger <lhh@redhat.com>
Reviewed-by: Fabio M. Di Nitto <fdinitto@redhat.com>
---
 rgmanager/include/cpglock-internal.h |    4 ++
 rgmanager/src/daemons/main.c         |   75 +++++++++++++++++++++++++++++++++-
 2 files changed, 78 insertions(+), 1 deletions(-)

diff --git a/rgmanager/include/cpglock-internal.h b/rgmanager/include/cpglock-internal.h
index d6734eb..27917c7 100644
--- a/rgmanager/include/cpglock-internal.h
+++ b/rgmanager/include/cpglock-internal.h
@@ -11,6 +11,10 @@
 #define CPG_LOCKD_SOCK "/var/run/cpglockd.sk"
 #endif
 
+#ifndef CPGLOCKD_BIN_PATH
+#	define CPGLOCKD_BIN_PATH "/usr/sbin/cpglockd"
+#endif
+
 #include <stdint.h>
 
 typedef enum {
diff --git a/rgmanager/src/daemons/main.c b/rgmanager/src/daemons/main.c
index 29af894..87ea6e7 100644
--- a/rgmanager/src/daemons/main.c
+++ b/rgmanager/src/daemons/main.c
@@ -25,6 +25,8 @@
 #include <groups.h>
 #include <rg_dbus.h>
 
+#include <cpglock-internal.h>
+
 #ifdef WRAP_THREADS
 void dump_thread_states(FILE *);
 #endif
@@ -792,6 +794,74 @@ statedump(int __attribute__ ((unused)) sig)
 	signalled++;
 }
 
+static int
+cpglockd_needed(void)
+{
+	char *v;
+	int ccsfd;
+	int start_cpglockd = 0;
+
+	ccsfd = ccs_force_connect(NULL, 0);
+	if (ccsfd < 0)
+		return -1;
+
+	if (ccs_get(ccsfd, "/cluster/cman/altmulticast/@addr", &v) == 0) {
+		if (v != NULL) {
+			int ret;
+			free(v);
+
+			ret = ccs_get(ccsfd,
+					"/cluster/clusternodes/clusternode/altname/@name", &v);
+			if (ret == 0) {
+				if (v != NULL) {
+					free(v);
+					start_cpglockd = 1;
+				}
+			}
+		}
+	}
+
+	if (start_cpglockd) {
+		if (ccs_get(ccsfd, "/cluster/totem/@rrp_mode", &v) == 0) {
+			if (v != NULL) {
+				if (!strcasecmp(v, "none"))
+					start_cpglockd = 0;
+				free(v);
+			}
+		}
+	}
+
+	ccs_disconnect(ccsfd);
+	return start_cpglockd;
+}
+
+static int
+cpglockd_start(void) {
+	int pid;
+	int status;
+
+	pid = fork();
+	if (pid == -1)
+		return -1;
+
+	if (pid) {
+		waitpid(pid, &status, 0);
+		if (!WIFEXITED(status) || WEXITSTATUS(status)) {
+			logt_print(LOG_NOTICE, "Unable to start cpglockd\n");
+			return -1;
+		}
+	} else {
+		int i;
+
+		for (i = 3 ; i < __FD_SETSIZE ; i++)
+			close(i);
+
+		execl(CPGLOCKD_BIN_PATH, "cpglockd", NULL);
+		exit(-1);
+	}
+
+	return 0;
+}
 
 static int
 rgmanager_disabled(int ccsfd)
@@ -1056,6 +1126,10 @@ main(int argc, char **argv)
 		return -1;
 	}
 
+	xmlInitParser();
+	if (cpg_locks || cpglockd_needed() == 1)
+		cpglockd_start();
+
 	if (!cpg_locks) {
 		if (clu_lock_init(rgmanager_lsname) != 0) {
 			printf("Locks not working!\n");
@@ -1092,7 +1166,6 @@ main(int argc, char **argv)
 	   We know we're quorate.  At this point, we need to
 	   read the resource group trees from ccsd.
 	 */
-	xmlInitParser();
 	configure_rgmanager(-1, debug, &cluster_timeout);
 	if (shutdown_pending == 1)
 		goto out_ls;
-- 
1.7.7.6


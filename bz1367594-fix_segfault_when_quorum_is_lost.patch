From 75a02d64a5f11f9a3f1d84a6606e693a259f8c5b Mon Sep 17 00:00:00 2001
From: Ryan McCabe <rmccabe@redhat.com>
Date: Tue, 1 Nov 2016 11:43:47 -0400
Subject: [PATCH] rgmanager: Fix segfault when quorum is lost

Fix a segfault that could occur following recovery caused by a loss
of quorum.

Patch from John Ruemker <jruemker@redhat.com>

Resolves: rhbz#1367594
Signed-off-by: Ryan McCabe <rmccabe@redhat.com>
---
 rgmanager/src/daemons/rg_state.c  | 12 ++++++++++++
 rgmanager/src/daemons/rg_thread.c |  2 +-
 2 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/rgmanager/src/daemons/rg_state.c b/rgmanager/src/daemons/rg_state.c
index fe5d99d..2527f19 100644
--- a/rgmanager/src/daemons/rg_state.c
+++ b/rgmanager/src/daemons/rg_state.c
@@ -905,6 +905,8 @@ svc_migrate(const char *svcName, int target)
 		return RG_EINVAL;
 
 	membership = member_list();
+	if (!membership)
+		return RG_EFAIL;
 	m = memb_id_to_p(membership, target);
 	if (!m) {
 		free_member_list(membership);
@@ -1815,6 +1817,8 @@ handle_relocate_req(char *svcName, int orig_request, int preferred_target,
 		/* TODO: simplify this and don't keep alloc/freeing 
 		   member lists */
 		allowed_nodes = member_list();
+		if (!allowed_nodes)
+			return RG_EFAIL;
 
 		m = memb_id_to_p(allowed_nodes, preferred_target);
 		if (m && m->cn_member) {
@@ -1849,6 +1853,8 @@ handle_relocate_req(char *svcName, int orig_request, int preferred_target,
 	if (preferred_target > 0) {
 
 		allowed_nodes = member_list();
+		if (!allowed_nodes)
+			return RG_EFAIL;
 		/*
 	   	   Mark everyone except me and the preferred target DOWN for now
 		   If we can't start it on the preferred target, then we'll try
@@ -1927,6 +1933,8 @@ handle_relocate_req(char *svcName, int orig_request, int preferred_target,
 		allowed_nodes = member_list();
 		//count_resource_groups(allowed_nodes);
 	}
+	if (!allowed_nodes)
+		return RG_EFAIL;
 	member_list_shuffle(allowed_nodes);
 
 	if (preferred_target > 0)
@@ -2081,6 +2089,8 @@ handle_start_req(char *svcName, int req, int *new_owner)
  
 	need_check = have_exclusive_resources();
 	membership = member_list();
+	if (!membership)
+		return RG_EFAIL;
 
 	/*
 	 * When a service request is from a user application (eg, clusvcadm),
@@ -2218,6 +2228,8 @@ handle_start_remote_req(char *svcName, int req)
 
 	need_check = have_exclusive_resources();
 	membership = member_list();
+	if (!membership)
+		return RG_EFAIL;
 
 	/* XXX ok, so we need to say "should I start this if I was the
 	   only cluster member online */
diff --git a/rgmanager/src/daemons/rg_thread.c b/rgmanager/src/daemons/rg_thread.c
index c08d8aa..6f06b6f 100644
--- a/rgmanager/src/daemons/rg_thread.c
+++ b/rgmanager/src/daemons/rg_thread.c
@@ -219,7 +219,7 @@ resgroup_thread_main(void *arg)
 	while(1) {
 		pthread_mutex_lock(&reslist_mutex);
  		pthread_mutex_lock(&my_queue_mutex);
-		if ((req = rq_next_request(&my_queue)) == NULL) {
+		if (!rg_quorate() || (req = rq_next_request(&my_queue)) == NULL) {
 			/* We're done.  No more requests.
 			   We're about to kill our thread, so exit the
 			   loop with the lock held. */
-- 
2.5.5

